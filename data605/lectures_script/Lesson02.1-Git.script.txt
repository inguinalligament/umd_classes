# ##############################################################################
# Bash / Linux: Resources
# ##############################################################################

This slide provides resources for learning Linux, focusing on how Linux operates
and how to manage it. Key areas include understanding processes, file
permissions, and virtual memory. For beginners, there is a tutorial on basic
command-line usage, covering commands like `find`, `xargs`, `chmod`, and
`chown`. For those seeking deeper knowledge, "The Linux Command Line" is
recommended for mastering Linux commands and administration. These resources are
essential for anyone looking to effectively use and manage a Linux system.

Let's move on to explore resources for Git, a crucial tool for version control.

# ##############################################################################
# Git Resources
# ##############################################################################

This slide offers resources for learning Git, a vital tool for version control
in software development. It includes a tutorial to get started and emphasizes
the importance of using Git in projects. For advanced learning, "Pro Git" is
recommended, which is available for free. Several web resources provide
additional guidance, including interactive sites like "Oh Sh\*t, Git!?!" and
"Learn Git Branching" for hands-on practice. These resources are designed to
help users understand Git concepts and improve their skills in managing code
changes effectively.

Next, we will delve into the concept of Git branching and its significance.

# ##############################################################################
# Git Branching
# ##############################################################################

This slide explains the concept of branching in Git, which allows developers to
work on different parts of a project without affecting the main codebase.
Branching is useful for experimenting, avoiding disruptions in the main branch,
and integrating updates smoothly. Git's branching is lightweight and
instantaneous, as branches are simply pointers to commits. Git stores data as
snapshots, making branching and merging frequent and efficient. This approach is
surprising to those used to other version control systems, as it encourages
frequent branching to organize and isolate work effectively.

# ##############################################################################
# Git Branching
# ##############################################################################

This slide explains the concept of branching in Git. The `master` or `main`
branch is the primary branch that points to the last commit and moves forward
with each new commit. The `HEAD` is a pointer to the current local branch, such
as `master` or `testing`. Using `git checkout <BRANCH>`, you can switch between
branches. Creating a new branch with `git branch testing` establishes a new
pointer that can move independently. Divergent history occurs when work
progresses on two separate branches, allowing for parallel development paths.

Transition: Now, let's see how to switch between these branches using Git
Checkout.

# ##############################################################################
# Git Checkout
# ##############################################################################

This slide focuses on the `git checkout` command, which allows you to switch
between branches. When you use `git checkout`, the `HEAD` pointer moves to the
new branch, and the files in your working directory change to match the branch's
state. For example, if you have two branches, `master` and `testing`, and you
are currently on `master`, executing `git checkout testing` will move the
pointer and change the working directory to reflect the `testing` branch. You
can continue working and committing on `testing`, and the pointer will move
forward with each commit.

Transition: Next, we will discuss how to branch and merge in Git for effective
project management.

# ##############################################################################
# Git Branching and Merging
# ##############################################################################

This slide introduces branching and merging in Git, with links to tutorials for
working on the main branch and handling hot fixes. You start with a project that
has some commits and create a new branch to work on a feature, such as "Issue
53". By using the command `git checkout -b iss53`, you create and switch to a
new branch named `iss53`. You can then work on the feature, make changes, and
commit them. This process allows you to develop new features or fixes in
isolation before merging them back into the main branch.

# ##############################################################################
# Git Branching and Merging
# ##############################################################################

This slide explains how to apply a hotfix to the master branch using Git. The
process involves creating a new branch for the hotfix, making the necessary
changes, and then merging it back into the master branch. This ensures that
urgent fixes can be applied without disrupting ongoing work in other branches.
The slide also introduces the concept of fast forward, which occurs when there
is a straightforward path from one branch to another without any divergent
history. This means that the changes can be applied directly without any complex
merging.

Transition: Let's continue with how to handle ongoing work on a branch.

# ##############################################################################
# Git Branching and Merging
# ##############################################################################

This slide focuses on continuing work on a specific branch, such as `iss53`, and
eventually merging it back into the master branch. It highlights the process of
switching to the branch, completing the work, and then merging it back. If the
branch has diverged from the master, Git cannot perform a fast forward merge,
requiring a 3-way merge commit. This creates a new snapshot that combines
changes from both branches. After merging, the branch can be safely deleted to
keep the repository clean.

Transition: Now, let's explore the concept of fast forward merges in more
detail.

# ##############################################################################
# Fast Forward Merge
# ##############################################################################

This slide explains the fast forward merge, which occurs when there is no
divergent history between branches. In this case, Git simply moves the branch
pointer forward from one commit to another, effectively incorporating the
changes without creating a new merge commit. The slide emphasizes the mental
model of a branch as a pointer to the latest commit. For example, if `C4'` is
reachable from `C3`, Git can move the master branch pointer to `C4'` during the
merge. This process is efficient and keeps the commit history linear and clean.

# ##############################################################################
# Merging Conflicts
# ##############################################################################

Merging conflicts in Git occur when changes in different branches clash. This
can happen if the same file is modified in both branches or if one branch
modifies a file while another deletes it. When this happens, Git cannot
automatically merge the branches and pauses the process, adding conflict
resolution markers to the files. Users must manually resolve these conflicts by
editing the files, marking them as resolved with `git add`, and committing the
changes. Tools like PyCharm or VS Code can assist in this process, making it
easier to handle conflicts.

Transition: Now, let's explore another important Git concept: rebasing.

# ##############################################################################
# Git Rebasing
# ##############################################################################

Git offers two methods to merge divergent histories: merging and rebasing.
Merging involves creating a new commit that combines changes from different
branches. In contrast, rebasing re-applies changes from one branch onto another,
effectively rewriting the commit history. This process involves checking out the
branch to be rebased, syncing it with the target branch, and applying the
changes. Only the current branch is affected, and the branch is fast-forwarded
to include the new changes. Rebasing can help maintain a cleaner project history
by avoiding unnecessary merge commits.

Transition: Let's delve into the benefits and uses of rebasing.

# ##############################################################################
# Uses of Rebase
# ##############################################################################

Rebasing is beneficial for maintaining a clean project history, making it appear
as though all work was done sequentially, even if it was done in parallel. This
is particularly useful when contributing to projects you don't maintain. As a
developer, you can work on your branch and rebase it onto the main branch when
ready to integrate your work. This simplifies the process for the project
maintainer, who can then easily fast forward or apply changes without dealing
with conflicts, streamlining the integration process.

# ##############################################################################
# Golden Rule of Rebasing
# ##############################################################################

Rebasing is a process in Git where you replace existing commits with new ones
that are similar but not identical. This can cause issues if others have based
their work on the original commits. If you rebase and then force push, your
collaborators will need to re-merge their work. To avoid this, it's best to
follow some guidelines. Strictly, you should never rebase commits that are
outside your repository. However, if you're the only one using a branch, you can
rebase it even if it's on a server.

Transition: Now, let's explore the philosophical considerations between rebase
and merge.

# ##############################################################################
# Rebase vs Merge: Philosophical Considerations
# ##############################################################################

Choosing between rebase and merge depends on how you view commit history. If you
see history as a record of what actually happened, even if it's messy, you
should use git merge. This approach keeps the history intact. On the other hand,
if you believe history should be presented in the best way for future readers,
you might prefer git rebase. This allows you to clean up and organize the
history to make it more understandable.

Transition: Let's delve deeper into the practical considerations of rebase
versus merge.

# ##############################################################################
# Rebase vs Merge: Practical Considerations
# ##############################################################################

The debate between rebase and merge can be time-consuming and often
unproductive. In practice, the choice is often made by the project's
maintainers. A good approach is to rebase changes in your local repository,
especially if the branch is yours alone. Use git pull --rebase to tidy up your
work history. However, if the branch is shared, you should use git merge to
ensure everyoneâ€™s work is preserved. Personally, I prefer to squash-and-merge
branches to master, as my commits are usually just checkpoints rather than
complete pieces of work.

# ##############################################################################
# Remote Branches
# ##############################################################################

Remote branches are essentially pointers to branches in remote repositories.
They help you keep track of the state of a branch on a remote server. When you
run `git remote -v`, you can see the URLs for fetching and pushing code.
Tracking branches are local references that represent the state of the remote
repository. For example, your local `master` branch might track `origin/master`.
You cannot directly change a remote branch, but you can update your tracking
branch by fetching or pulling from the remote. To share your local work, you
need to push your branch to the remote repository.

Transition: Now, let's explore how Git workflows help in organizing and
collaborating on projects.

# ##############################################################################
# Git Workflows
# ##############################################################################

Git workflows are strategies for using Git to collaborate effectively. They
often involve long-running branches, which are branches that remain open and
represent different levels of stability. The `master` branch is typically always
ready for release, while the `develop` branch is used for ongoing development.
Topic or feature branches are created for specific tasks or features. Once these
branches are stable enough, they are merged into the main branches. This
structure helps teams manage code changes and ensure stability in the main
codebase.

Transition: Let's delve deeper into the role of topic branches in Git workflows.

# ##############################################################################
# Git Workflows
# ##############################################################################

Topic branches are short-lived branches created for a single feature or task.
Examples include branches named `hotfix` or `wip-XYZ`. These branches are easy
to review and are isolated from the rest of the codebase, making them ideal for
focused development. Git excels in handling these branches, unlike some other
version control systems. For instance, you might start a branch `iss91`, make
changes, and then create a new version `iss91v2`. Sometimes, branches like
`dumbidea` might be merged into `master`, and you can use squash-and-merge to
combine changes from `iss91v2`.

# ##############################################################################
# Centralized Workflow
# ##############################################################################

In a centralized workflow using a centralized version control system (VCS),
developers check out code from a central repository, make local modifications,
and then push changes back to the central hub. If there are no conflicts with
the latest version, the process is straightforward; otherwise, developers must
merge changes. In Git, developers with push access to the central repository
must fetch and merge changes before pushing. They cannot overwrite each other's
code, ensuring only fast-forward changes are made. This workflow emphasizes the
importance of coordination and conflict resolution among developers.

Transition: Let's explore how forking workflows differ from centralized
workflows.

# ##############################################################################
# Forking Workflows
# ##############################################################################

In forking workflows, developers typically do not have direct permission to
update branches on a project. Core contributors have read-write permissions,
while others have read-only access. The solution is to fork a repository,
allowing external contributors to clone the repo, create a branch, and push
changes to their fork. They then prepare a pull request (PR) for the project
maintainer, who reviews, accepts, and integrates the PR. The project maintainer
pulls the code when ready, rather than external contributors pushing it. This
method, known as the GitHub workflow, was popularized by GitHub, which was
acquired by Microsoft for 7.5 billion USD.

Transition: Now, let's look at the integration-manager workflow, a classic model
for open-source development.

# ##############################################################################
# Integration-Manager Workflow
# ##############################################################################

The integration-manager workflow is a traditional model for open-source
development, used by projects like Linux and GitHub's forking workflow. In this
model, one repository is the official project, and only the project maintainer
pushes to the public repo. Contributors have read access to others' public repos
and fork the project into a private copy, where they have write access. They
make changes, push them to their public copy, and send a pull request to the
maintainer. The maintainer adds the contributor's repo as a remote, merges
changes into a local branch, tests them, and then pushes the branch to the
official repo. This workflow ensures a structured and controlled integration
process.

# ##############################################################################
# Git log
# ##############################################################################

This slide explains how the `git log` command provides information about commits
in a Git repository. It highlights the concept of references, which are pointers
to specific commits or branches. For example, `HEAD` is the commit you are
currently working on, while `origin/master` refers to a remote branch. Local
branches like `experiment` and specific commits like `d921970` are also examples
of references. The slide also introduces the caret (`^`) notation, which helps
navigate to parent commits. For instance, `HEAD^` refers to the commit before
the current `HEAD`, and `^2` is equivalent to `^^`, indicating the second parent
in a merge commit.

Let's move on to understanding dot notation in Git.

# ##############################################################################
# Dot notation
# ##############################################################################

This slide covers the double-dot and triple-dot notations in Git, which are used
to compare commits between branches. The double-dot notation (`1..2`) shows
commits reachable from the second reference but not from the first, essentially
highlighting differences. For example, `git log master..experiment` lists
commits `D` and `C`, while `git log experiment..master` lists `F` and `E`. The
triple-dot notation (`1...2`) displays commits reachable from either branch but
not both, acting like a union excluding the intersection. For instance,
`git log master...experiment` results in commits `F`, `E`, `D`, and `C`.

Now, let's explore some advanced Git features.

# ##############################################################################
# Advanced Git
# ##############################################################################

This slide introduces advanced Git features that enhance workflow efficiency.
Stashing allows you to save the current state of your working directory,
including modified and staged files, onto a stack for later use. Cherry-picking
enables you to apply a single commit from one branch onto another, facilitating
selective changes. The `rerere` feature, short for "Reuse Recorded Resolution,"
caches solutions to conflicts, making future resolutions easier. Lastly,
submodules and subtrees allow a project to include other Git projects, enabling
modular development and management of dependencies within a repository.

# ##############################################################################
# Advanced Git
# ##############################################################################

Description of the slide

- Git bisect is a useful tool for finding the specific commit that introduced a
  bug in your code. It works by identifying when a bug appears at the top of the
  tree and helps trace back to the unknown revision where it started. You can
  use a script that returns 0 if the code is good and a non-zero value if it's
  bad. Git bisect will then find the revision where the script's result changes
  from good to bad.

- The filter-branch command allows you to rewrite the history of your repository
  in a scriptable way. This can be useful for tasks like changing an email
  address or removing a sensitive file. It works by checking out each version,
  running a command, and committing the result.

- Git hooks are scripts that run automatically before certain Git actions, such
  as committing or merging. They can be used to automate tasks or enforce
  certain rules.

Transition: Now, let's explore GitHub and its significance in the world of Git
repositories.

# ##############################################################################
# GitHub
# ##############################################################################

Description of the slide

- GitHub, acquired by Microsoft for $7.5 billion, is the largest host for Git
  repositories. It supports over 100 million open-source projects and offers
  features like pull requests, forks, issue tracking, code review,
  collaboration, wikis, and actions for continuous integration and continuous
  deployment (CI/CD).

- Forking a project in open-source communities can have a negative connotation,
  as it involves modifying and creating a competing project. However, in GitHub
  parlance, forking means copying a project to contribute without having push or
  write access. This allows users to make changes and propose them back to the
  original project.
